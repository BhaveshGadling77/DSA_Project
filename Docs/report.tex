\documentclass[12pt,a4paper]{article}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{setspace}
\usepackage{times}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{tocloft}
\usepackage[hidelinks]{hyperref}

% Code listing configuration
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% Set line spacing
\onehalfspacing

\begin{document}

% ====================== Page 1: Title Page ======================
\thispagestyle{empty}
\begin{center}
    
    {\large \textit{A report on}}\\[0.5cm]
    
    {\Huge \textbf{Event Management System using C}}\\[1.5cm]
    
    \textit{submitted in the completion of}\\
    \textit{Data Structures and Algorithms Lab}\\
    \textit{of}\\[0.5cm]
    
    {\Large \textbf{SY COMP}}\\[0.5cm]
    
    \textit{in}\\[0.5cm]
    
    {\Large \textbf{Computer Engineering}}\\[0.5cm]
    
    \textit{by}\\[0.5cm]
    
    % {\Large \textbf{Sumit Desai, Piyush Deshpande and Bhavesh Gadling}}\\[0.5cm]
    % {\large 612415049, 612415052 and 612415061}\\[0.5cm]
    \begin{center}
% {\large \textbf{Submitted by:}}\\[0.4cm]

\begin{tabular}{@{} p{0.40\textwidth} p{0.20\textwidth} @{}}
\textbf{1. Sumit Desai} & \textbf{[612415049]} \\
\emph{Attendee Management Module}& \\[0.2cm] 

\textbf{2. Piyush Deshpande} & \textbf{[612415052]} \\
\emph{Event Management Module}& \\ [0.2cm] 

\textbf{3. Bhavesh Gadling} & \textbf{[612415061]} \\
\emph{Login Authentication Module}& \\[0.2cm]
\end{tabular}

\vspace{0.4cm}
{\small \textbf{All members contributed in Testing \& Documentation}}\\[1.0cm]

\end{center}

    \textit{Under the guidance of}\\[0.5cm]
    
    {\Large \textbf{Prof. Tina Francis}}\\
    \textit{Professor}\\
    \textit{Department of Computer Engineering,}\\
    \textit{COEP Technological University (COEP Tech)}\\
    (A Unitary Public University of Govt. of Maharashtra)\\
    Shivajinagar, Pune-411005, Maharashtra, INDIA\\[1cm]
    
    \textbf{December 2025}
    
    \vfill
    
\end{center}
\newpage

% ====================== Page 2: Table of Contents ======================
\pagenumbering{arabic}
\tableofcontents
\newpage

% ====================== Page 3: Introduction ======================
\section{Introduction}
Event management---whether in universities, corporations, or community organizations---requires careful coordination of schedules, venues, and participants. The system described in this report is a compact, console-based Event Management System (EMS) implemented in C. It is built to illustrate how classical data structures and algorithms can be applied to real-world problems: we chose each data structure where it naturally solves a core problem rather than forcing a tool to fit.

This EMS integrates three principal modules:
\begin{itemize}
    \item \textbf{Login and Registration Module:} Handles user authentication, maintains role information (organizer/attendee), and exposes a simple API for other modules.
    \item \textbf{Event Management Module:} Creates, updates, and deletes events; enforces scheduling rules and venue constraints.
    \item \textbf{Attendee Management Module:} Manages registrations, attendance marking, and attendee-level reporting.
\end{itemize}

Each module communicates through a shared persistence layer (CSV files) and well-defined function interfaces. The aim is to keep the core clean and modular so the system can later be extended with a graphical or web front-end without changing the essential algorithms.

\subsection{Definitions}
To avoid ambiguity, the central terms used in this report are defined succinctly:
\begin{itemize}
    \item \textbf{Event:} A scheduled occurrence identified by an eventID and described by attributes such as title, date, start and end times, venue, registration deadline, and maximum capacity.
    \item \textbf{Venue:} A named location (physical or virtual) with an identifier, capacity, and availability schedule.
    \item \textbf{Organizer:} A user role that can create or manage events and view attendee lists.
    \item \textbf{Attendee:} A user who may register for events and whose attendance can be recorded.
    \item \textbf{Registration:} A record linking an attendee to an event; it can be created, cancelled, or updated.
\end{itemize}

These definitions inform the data model and the function interfaces we implement.

\subsection{Applications}
The EMS can be deployed in multiple contexts. We outline four typical application domains and highlight relevant capabilities.

\subsubsection{University Events}
Universities manage seminars, practical sessions, and cultural events. The EMS assists by:
\begin{itemize}
    \item Preventing classroom and auditorium double-bookings.
    \item Tracking attendance for credit or participation certificates.
    \item Producing departmental reports and historical logs.
\end{itemize}

\subsubsection{Corporate Events}
For organizations, the EMS supports:
\begin{itemize}
    \item Efficient meeting-room allocation and conflict avoidance.
    \item Attendance tracking for compliance and payroll (if needed).
    \item Analytics for resource usage and event popularity.
\end{itemize}

\subsubsection{Social Gatherings}
Community and social event organizers benefit from:
\begin{itemize}
    \item Simple registration flows for members.
    \item Exportable attendee lists for on-site check-in.
    \item Lightweight reporting for future planning.
\end{itemize}

\subsubsection{Technical Conferences}
Conferences require multi-track scheduling and scalability:
\begin{itemize}
    \item Parallel sessions with capacity and speaker coordination.
    \item Conflict-free scheduling using interval trees for overlap checks.
    \item Attendance certificates and session analytics.
\end{itemize}

\newpage

% ====================== Page 4: Data Structures Used ======================
\section{Data Structures used}
Choosing the right data structure for each subsystem is fundamental to building an efficient EMS. The subsequent subsections explain our chosen structures, their justification, and their operational semantics.

\subsection{AVL Tree}
\subsubsection{The AVL tree Data Structure}
An AVL tree defined as a self-balancing Binary Search Tree (BST) where the absolute difference between heights of left and right subtrees for any node cannot be more than one.

The difference between the heights of the left subtree and the right subtree for any node is known as the balance factor of the node.

In an AVL Tree, the balance factors of all the nodes has to be strictly -1, 0 or 1.

\subsubsection{Why AVL Trees?}
Using AVL trees can significantly improve the efficiency of operations like searching, inserting, and deleting data.

1. \textbf{Efficient Searching:} AVL trees are balanced, meaning the depth of the tree is kept to a minimum. This ensures that searching for a specific item in the tree is fast, even as the tree grows larger.

2. \textbf{Balanced Structure:} Unlike regular binary search trees, AVL trees automatically balance themselves after each operation. This prevents the tree from becoming lopsided or skewed, which could slow down operations.

3. \textbf{Predictable Performance:} Because AVL trees maintain their balance, their performance is consistent. Regardless of the order in which data is inserted, the tree maintains its optimal structure, leading to predictable and reliable performance.

4. \textbf{Optimized for Event Management:} AVL trees are commonly used in applications where fast searching and sorting are essential, such as event management systems. Their efficient structure makes them ideal for handling large volumes of events.

\subsubsection{Worst case Time complexities of AVL Tree}
\begin{itemize}
    \item \textbf{Search/Lookup:} In the worst case, the search operation in an AVL tree requires traversing from the root to a leaf node along a path of height $h$, where $h$ is the height of the tree. Since AVL trees are balanced and their height is $O(\lg n)$, where $n$ is the number of nodes, the worst-case time complexity for search is $O(\lg n)$.
    \item \textbf{Insertion:} $O(\lg n)$
    \item \textbf{Deletion:} $O(\lg n)$
    \item \textbf{Finding maximum/minimum element:} $O(\lg n)$
\end{itemize}

\subsection{Singly Linked List}
\subsubsection{The Singly Linked List Data Structure}
A singly linked list stores nodes that hold data and a pointer to the next node. For attendees, the node encapsulates the attendee record; for small sequences of events, it can also be used for ordered traversal or temporary lists.

\begin{lstlisting}[language=C, caption=Attendee and node definitions from attendee.h]
typedef struct Attendee {
    int attendeeID;
    char name[50];
    char email[50];
    unsigned long long phoneNo;
    int eventID;
    int eventsRegistered;
    char status[15]; // present, absent or only registered
    char registrationDate[30];
} Attendee;

typedef struct Node {
    Attendee data;
    struct Node* next;
} Node;
\end{lstlisting}

\subsubsection{Why Singly Linked List?}
The primary reasons for choosing linked lists for attendee storage are:
\begin{itemize}
    \item \textbf{Dynamic size:} The number of attendees varies unpredictably; linked lists grow as required with no pre-allocation.
    \item \textbf{Fast head insertion:} Adding recent registrations at the head is an $O(1)$ operation.
    \item \textbf{Simple persistence mapping:} Each node translates naturally to a CSV row; loading simply reconstructs the list.
    \item \textbf{Memory efficiency:} Only required nodes are allocated, reducing wasted space.
\end{itemize}

\subsubsection{Worst case Time complexities of Singly Linked List}
\begin{itemize}
    \item Insertion at head: $O(1)$
    \item Search: $O(n)$
    \item Deletion (search + remove): $O(n)$
    \item Traversal (reporting): $O(n)$
\end{itemize}

% ====================== Page 5: More Data Structures ======================
\subsection{Hash Table}
\subsubsection{Hash Functions Used}
Venues are stored in a hash table using the modulus method:
\[
\text{index} = \text{venueID} \% 101
\]
We chose 101 (a prime) to minimize clustering for typical small venue sets.

\subsubsection{Collision Handling Strategy}
Separate chaining is used; each bucket is a linked list of venues. The operations are:
\begin{itemize}
    \item \textbf{Insertion} --- compute index, prepend to chain ($O(1)$ average)
    \item \textbf{Lookup} --- traverse short chain ($O(1 + \alpha)$ average)
    \item \textbf{Deletion} --- remove from chain with pointer update ($O(1)$ after traversal)
\end{itemize}
This approach is simple and robust for a small number of venues.

\subsection{Interval Tree}
\subsubsection{Interval Tree Properties}
To detect schedule conflicts efficiently, we use interval trees built for a particular venue and date. Each interval node stores the start and end times (converted to integer seconds) and the maximum end time of its subtree to allow efficient pruning during overlap queries.

\subsubsection{Use Cases in Event Scheduling}
When adding a new event, the system:
\begin{enumerate}
    \item Loads all events for the venue and date.
    \item Creates an interval tree keyed by start times.
    \item Queries the tree for overlap with the candidate event; if any overlap exists, booking is rejected.
\end{enumerate}

This reduces checking from $O(p^2)$ naive comparisons to $O(p \log p)$ for building and substantially fewer comparisons during querying.

\newpage

% ====================== Page 6: Time Complexity Analysis ======================
\section{Time Complexity Analysis of Various Algorithms}
This section provides comprehensive complexity analysis of all major operations implemented in the EMS, covering linked list operations, tree operations, sorting algorithms, file operations, and module-specific functions.

\subsection{Linked List Operations}
\subsubsection*{Attendee Management Operations:}
\begin{itemize}
    \item \textbf{Insertion at head:} $O(1)$ - Used when registering new attendees
    \item \textbf{Linear search:} $O(n)$ - Used for duplicate checks, attendee lookup
    \item \textbf{Deletion:} $O(n)$ - Used when unregistering attendees (search + remove)
    \item \textbf{Traversal:} $O(n)$ - Used for viewing all attendees, statistics calculation
\end{itemize}

\subsubsection*{Event Linked List Operations:}
\begin{itemize}
    \item \textbf{Add to list:} $O(1)$ - Adding event nodes at head
    \item \textbf{Traversal for viewing:} $O(n)$ - Displaying all events
    \item \textbf{Clean past events:} $O(n)$ - Single pass to identify expired events
\end{itemize}

\subsection{Tree Operations}
\subsubsection*{AVL Tree Operations (Event Management):}
\begin{itemize}
    \item \textbf{Insertion:} $O(\log n)$ - Inserting new event with rebalancing
    \item \textbf{Search by ID:} $O(\log n)$ - Searching for specific event
    \item \textbf{Deletion:} $O(\log n)$ - Removing event with rebalancing
    \item \textbf{Height calculation:} $O(1)$ - Accessing stored height
    \item \textbf{Rotations:} $O(1)$ - All four rotation types
\end{itemize}

\subsubsection*{Interval Tree Operations:}
\begin{itemize}
    \item \textbf{Tree construction:} $O(m \log m)$ - Building from $m$ intervals
    \item \textbf{Overlap query:} $O(\log m)$ in balanced case - Checking for scheduling conflicts
    \item \textbf{Insertion:} $O(\log m)$ - Adding new interval to tree
\end{itemize}

\subsection{Sorting Algorithms}
\subsubsection*{QuickSort Implementation:}
\begin{itemize}
    \item \textbf{Average case:} $O(n \log n)$ - Used for sorting events by date/time/ID
    \item \textbf{Worst case:} $O(n^2)$ - Rare with proper pivot selection
    \item \textbf{Partition:} $O(n)$ - For each recursive call
\end{itemize}

% ====================== Page 7: More Time Complexity Analysis ======================
\subsubsection*{Comparison Functions:}
\begin{itemize}
    \item compareChronological(): $O(1)$ - Comparing dates and times
    \item compareByDate(): $O(1)$ - Date comparison only
    \item compareByID(): $O(1)$ - Integer comparison
\end{itemize}

\subsubsection*{Array Conversion:}
\begin{itemize}
    \item listToArray(): $O(n)$ - Converting linked list to array for sorting
\end{itemize}

\subsection{File Operations}
\subsubsection*{CSV File Operations:}
\begin{itemize}
    \item \textbf{Loading attendees:} $O(n)$ - Reading event\_\{id\}.csv
    \item \textbf{Saving attendees:} $O(n)$ - Writing to CSV file
    \item \textbf{Fetching user data:} $O(k)$ - Scanning userAttendee.csv with $k$ users
    \item \textbf{Updating events attended:} $O(k)$ - Updating user record with temp file
\end{itemize}

\subsubsection*{Persistence Operations:}
\begin{itemize}
    \item \textbf{Atomic updates:} $O(n)$ - Using temporary files and rename()
    \item \textbf{Parsing with strtok():} $O(m)$ per line - Robust CSV parsing
\end{itemize}
\newpage
\subsection{Module-Specific Operations}
\subsubsection*{Login Module:}
\begin{itemize}
    \item \textbf{User registration:} $O(k)$ - Checking existing users in CSV
    \item \textbf{User login:} $O(k)$ - Linear search through user database
    \item \textbf{Logout:} $O(1)$ - Simple status update
    \item \textbf{getDetails():} $O(1)$ - Returning global userStatus struct
\end{itemize}

\subsubsection*{Attendee Module:}
\begin{itemize}
    \item \textbf{Register attendee:} $O(k + n)$ - User fetch + attendee list operations
    \item \textbf{Unregister attendee:} $O(n)$ - Search and deletion
    \item \textbf{Mark attendance:} $O(n)$ - Linear search and update
    \item \textbf{View statistics:} $O(n)$ - Single traversal for counting
    \item \textbf{Search attendee:} $O(n)$ - Linear search by ID
\end{itemize}

\subsubsection*{Event Module:}
\begin{itemize}
    \item \textbf{Add event:} $O(\log m + p \log p)$ - AVL insertion + interval conflict check
    \item \textbf{Delete event:} $O(\log m)$ - AVL deletion
    \item \textbf{Modify event:} $O(\log m)$ - Search + update
    \item \textbf{View events:} $O(n)$ - Linked list traversal
    \item \textbf{Sort events:} $O(n \log n)$ - QuickSort on array
    \item \textbf{Generate event ID:} $O(n)$ - Linear scan for maximum ID
    \item \textbf{Check venue availability:} $O(p \log p)$ - Interval tree construction and query
\end{itemize}

\newpage

% ====================== Page 8: Future Development ======================
\section{Future Goals to be achieved}
This section outlines pragmatic extensions that keep the current architecture intact while improving usability and scalability.

\subsection{Short-Term Goals}
\subsubsection*{Improve User Interface}
Upgrade the console UI with structured menus, ANSI-based coloring, and table formatting for readability. Tools and libraries: ncurses for Unix-like systems or cross-platform libraries for GUI front-ends.

\subsubsection*{Refactor Persistence Layer}
Abstract file operations behind a persistence module to allow easy substitution of CSV, serialized binary files, or database backends.

\subsection{Long term goals}
\subsubsection*{Database Integration}
Adopt SQLite for local, ACID-compliant storage or PostgreSQL/MySQL for enterprise deployments. Benefits: concurrency, indexes, transactions, and complex queries.

\subsubsection*{RESTful API and Web Front-End}
Expose the EMS functionality via an HTTP API and build a web interface (React/Vue) or a mobile app. This improves accessibility and allows multiple concurrent users.

\subsubsection*{Advanced Analytics and Notifications}
Add modules for attendance trends, event recommendations, and automated notifications (email/SMS) using simple integrations (SMTP, Twilio).

\subsection{Limitations of the Current System}
Although the EMS functions reliably for small to medium-scale usage, several limitations remain due to the simplicity of the underlying storage and interface:

\begin{itemize}
    \item \textbf{File-based Storage:} The use of CSV files limits scalability. As the number of users or events grows, file operations become slower and more prone to data inconsistency due to partial writes or unexpected termination.
    \item \textbf{Lack of Concurrency Support:} Two users cannot safely modify the system at the same time. Without locking mechanisms, simultaneous updates may lead to overwritten data.
    \item \textbf{Basic User Interface:} The console interface, while functional, does not provide the ease and accessibility of graphical or web-based platforms.
    \item \textbf{Security Limitations :} The system does not use password authentication. User details are stored in plain text, role-based access control is minimal, and the system is not intended for high-security applications.
    \item \textbf{No Real-Time Notifications:} Users must manually check event information; the system does not push reminders or updates.
\end{itemize}

\newpage

% ====================== Page 9: Appendix ======================
\section{Appendix: Data Structures and Implementation Details}
\subsection{Complete Data Structure Definitions}

\begin{lstlisting}[language=C, caption=Complete events.h header file (partial)]
#ifndef EVENTS_H
#define EVENTS_H

#include <stdio.h>

typedef struct Time {
    short unsigned int hour;
    short unsigned int minute;
    short unsigned int second;
} Time;

typedef struct date {
    short int date;
    short int month;
    short int year;
} date;

typedef struct event {
    int eventID;
    char eventName[32];
    int organiserID;
    int venueID;
    date eventDate;
    Time startTime;
    Time endTime;
    Time regDue;
    char* description;
} event;

// Linked list node for events
typedef struct EventNode {
    struct event evt;
    struct EventNode *next;
} EventNode;

// BST node for events by eventID
typedef struct EventBST {
    struct event evt;
    int height;
    struct EventBST *left;
    struct EventBST *right;
} EventBST;

// Function prototypes
void loadEvents(void);
void cleanPastEvents(void);
void viewEvents(void);
void sortEventByTime(void);
void sortEventChronological(void);
void sortEventByID(void);
event* searchEventID(void);
EventBST* newBSTNode(struct event e);
EventBST* insertBST(EventBST* root, struct event e);
EventBST* searchBST(EventBST* root, int eventID);
EventBST* minValueNode(EventBST* node);
EventBST* deleteBST(EventBST* root, int eventID);
date getCurrentDate(void);
int isPastEvent(struct date eventDate);
void quickSort(struct event arr[], int low, int high, int (*compare)(event, event));
int partition(struct event arr[], int low, int high, int (*compare)(event, event));
int compareChronological(event a, event b);
int compareByDate(event a, event b);
int compareByID(event a, event b);
int listToArray(event arr[]);
void addEvent(void);
void deleteEvent(void);
void modifyEvent(void);
void addToList(event e);
int checkValidTime(Time regEndtime, Time startTime, Time endTime);
int checkValidDate(date d);
int generateEventID(void);
void listEventsOfOrganizer();
void modifyEventDetailsInOrganizerFile(event modified);
int height(EventBST *n);
int maximum(int a, int b);
int getBalance(EventBST *n);
void calculateCost(event e);
EventBST *rightRotate(EventBST* y);
EventBST *leftRotate(EventBST *x);

#endif
\end{lstlisting}

\newpage

% ====================== Page 10: More Appendix ======================
\begin{lstlisting}[language=C, caption=Complete login\_registration.h header file]
#ifndef LOGIN_REGISTRATION_H
#define LOGIN_REGISTRATION_H

#include <stdbool.h>
#include <stdio.h>

typedef struct user {
    int userId;
    char name[64];
    unsigned int noOfEventsAttended;
    long long mobileNumber;
    char email[128];
} user;

typedef struct userStatus {
    int userId; // 0 if no user logged in and any number if user logged in
    char name[64];
    bool status; // true = logged in, false = not logged in
    bool isOrg; // if org = true, else false;
} userStatus;

int registerAsUser(int);
int loginAsUser(int);
int giveUserDetails(char *email, int id, FILE *fp, char *givenName);
int userValidation(user *a, int choice);
long long giveValidMobileNumber();
userStatus getDetails();
void logout();

#endif
\end{lstlisting}
\newpage
\begin{lstlisting}[language=C, caption=Complete Attendee.h header file (partial)]
#ifndef ATTENDEE_H
#define ATTENDEE_H

#include <stdbool.h>
#include "login_registration.h"
// Attendee structure
typedef struct Attendee {
    int attendeeID;
    char name[64];
    char email[128];
    unsigned long long phoneNo;
    int eventID;
    int eventsRegistered;
    char status[15];           // present, absent or only registered
    char registrationDate[30];
} Attendee;

// Linked List Node
typedef struct Node {
    Attendee data;
    struct Node* next;
} Node;

#define DECREASE 1
#define INCREASE 2
// Attendee Functions (only attendees can call)
void registerAttendeeForEvent(Node** head, int eventID, userStatus *user);
bool unregisterAttendee(Node** head, userStatus* user);
bool fetchUserData(int userID, Attendee *a);
void updateEventsAttended(int userID, int choice);

// organizer functions
void markAttendance(Node** head);
void viewAllAttendees(Node* head, int eventID);
void viewStatistics(Node *head);

// common function
void getCurrentDateTime(char* buffer);
void searchAttendee(Node* head);
void saveToFile(Node* head, int eventID);
void loadFromFile(Node** head, int eventID);
void freeList(Node* head);

#endif
\end{lstlisting}

\newpage

% ====================== Page 11: References ======================
\section{References}
\begin{enumerate}
    \item Ellis Horowitz, Sartaj Sahni and Sanguthevar Rajasekaran, \emph{Fundamentals of Computer Algorithms}, Universities Press, 2nd edition (2008).
    \item Sedgewick, R., \& Wayne, K. (2011). \emph{Algorithms}. Addison-Wesley.
    \item Kernighan, B. W., \& Ritchie, D. M. (1988). \emph{The C Programming Language} (2nd ed.). Prentice Hall.
    \item TutorialsPoint. \emph{Find out the current working directory in C/C++}. Retrieved from: \href{https://www.tutorialspoint.com/find-out-the-current-working-directory-in-c-cplusplus}{current working directory functions}
    \item YouTube. \emph{C Programming File Handling}. Retrieved from: \href{https://www.youtube.com/watch?v=ViqyHIyfHYo} {file handling}
    \item GeeksforGeeks. \emph{fseek() in C with example}. Retrieved from: \url{https://www.geeksforgeeks.org/cpp/fseek-in-c-with-example/}
    \item Stack Overflow. \emph{Does fscanf moves the passed file pointer ahead?} Retrieved from: \href{https://stackoverflow.com/questions/17802302/does-fscanf-moves-the-passed-file-pointer-ahead}{stack Overflow reference}
    \item Stack Overflow. \emph{How to check if a file has content or not using C?} Retrieved from: \href{https://stackoverflow.com/questions/13566082/how-to-check-if-a-file-has-content-or-not-using-c}{stack Overflow reference}
    \item GeeksforGeeks. \emph{C - File Pointer}. Retrieved from: \href{https://www.geeksforgeeks.org/c/c-file-pointer/}{file pointers}
    \item GeeksforGeeks. \emph{memset() in C with example}. Retrieved from: \href{https://www.geeksforgeeks.org/c/memset-c-example/}{memset function}
    \item GeeksforGeeks. \emph{fgets() and gets() in C language}. Retrieved from: \href{https://www.geeksforgeeks.org/c/fgets-function-in-c/}{fgets function}
\end{enumerate}

\newpage

% ====================== Page 12: Conclusion ======================
\section{Conclusions}
The Event Management System developed for this project demonstrates how classical data structures in C can be applied to a practical and meaningful real-world scenario. By employing linked lists for attendee management, AVL trees for fast event lookup, hash tables for venue indexing, and interval trees for scheduling conflict detection, the system combines efficiency with clarity.

The project provided hands-on experience with modular program design, file-based persistence, and algorithmic problem-solving. It also highlighted the importance of choosing appropriate data structures to meet specific operational requirements such as quick search, dynamic resizing, and conflict-free scheduling.

Although the system is intentionally simple, the architecture makes it easy to extend into a full-fledged management platform with better interfaces, database integration, and scalability. In its current form, the EMS succeeds in demonstrating fundamental concepts of software design and serves as a strong foundation for future academic or professional development.

\end{document}